#
# @lc app=leetcode id=924 lang=python3
#
# [924] Minimize Malware Spread
#
# https://leetcode.com/problems/minimize-malware-spread/description/
#
# algorithms
# Hard (42.02%)
# Likes:    317
# Dislikes: 262
# Total Accepted:    25K
# Total Submissions: 59.6K
# Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
# In a network of nodes, each node i is directly connected to another node j if
# and only if graph[i][j] = 1.
# 
# Some nodes initial are initially infected by malware.  Whenever two nodes are
# directly connected and at least one of those two nodes is infected by
# malware, both nodes will be infected by malware.  This spread of malware will
# continue until no more nodes can be infected in this manner.
# 
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network, after the spread of malware stops.
# 
# We will remove one node from the initial list.  Return the node that if
# removed, would minimize M(initial).  If multiple nodes could be removed to
# minimize M(initial), return such a node with the smallest index.
# 
# Note that if a node was removed from the initial list of infected nodes, it
# may still be infected later as a result of the malware spread.
# 
# 
# 
# 
# 
# 
# Example 1:
# 
# 
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# 
# 
# Example 2:
# 
# 
# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# 
# 
# Example 3:
# 
# 
# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1
# 
# 
# 
# 
# Note:
# 
# 
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] == 1
# 1 <= initial.length <= graph.length
# 0 <= initial[i] < graph.length
# 
# 
#

# @lc code=start
from collections import Counter

class DSU:
    def __init__(self, N):
        self.par = list(range(N))
        self.rnk = [0] * N
        self.siz = [1] * N

    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def union(self, x, y):
        xr, yr = map(self.find, (x, y))
        if xr == yr: return
        if self.rnk[xr] < self.rnk[yr]:
            xr, yr = yr, xr
        if self.rnk[xr] == self.rnk[yr]:
            self.rnk[xr] += 1

        self.par[yr] = xr
        self.siz[xr] += self.siz[yr]

    def size(self, x):
        return self.siz[self.find(x)]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # Depth First Search
        # Time  complexity: O(N^2)
        # Space complexity: O(N)

        # # 1. Color each component.
        # # colors[node] = the color of this node.
        # N = len(graph)
        # colors = {}
        # c = 0

        # def dfs(node, color):
        #     colors[node] = color
        #     for nei, adj in enumerate(graph[node]):
        #         if adj and nei not in colors:
        #             dfs(nei, color)

        # for node in range(N):
        #     if node not in colors:
        #         dfs(node, c)
        #         c += 1

        # # 2. Size of each color.
        # # size[color] = number of occurrences of this color.
        # size = Counter(colors.values())

        # # 3. Find unique colors.
        # color_count = Counter()
        # for node in initial:
        #     color_count[colors[node]] += 1

        # # 4. Answer
        # ans = float("inf")
        # for x in initial:
        #     c = colors[x]
        #     if color_count[c] == 1:
        #         if ans == float("inf"):
        #             ans = x
        #         elif size[c] > size[colors[ans]]:
        #             ans = x
        #         elif size[c] == size[colors[ans]] and x < ans:
        #             ans = x

        # return ans if ans < float("inf") else min(initial)


        # Union Find
        # Time  complexity: O(N^2)
        # Space complexity: O(N)
        dsu = DSU(len(graph))

        for j, row in enumerate(graph):
            for i in range(j):
                if row[i]:
                    dsu.union(i, j)

        count = Counter(dsu.find(u) for u in initial)

        ans = (-1, min(initial))
        for node in initial:
            root = dsu.find(node)
            # Only components with 1 affection count
            if count[root] == 1:
                if dsu.size(root) > ans[0]:
                    ans = dsu.size(root), node
                elif dsu.size(root) == ans[0] and node < ans[1]:
                    ans = dsu.size(root), node

        return ans[1]


        
# @lc code=end

