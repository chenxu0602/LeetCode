#
# @lc app=leetcode id=928 lang=python3
#
# [928] Minimize Malware Spread II
#
# https://leetcode.com/problems/minimize-malware-spread-ii/description/
#
# algorithms
# Hard (40.51%)
# Likes:    212
# Dislikes: 48
# Total Accepted:    10.1K
# Total Submissions: 24.7K
# Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
# (This problem is the same as Minimize Malware Spread, with the differences
# bolded.)
# 
# In a network of nodes, each node i is directly connected to another node j if
# and only if graph[i][j] = 1.
# 
# Some nodes initial are initially infected by malware.  Whenever two nodes are
# directly connected and at least one of those two nodes is infected by
# malware, both nodes will be infected by malware.  This spread of malware will
# continue until no more nodes can be infected in this manner.
# 
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network, after the spread of malware stops.
# 
# We will remove one node from the initial list, completely removing it and any
# connections from this node to any other node.  Return the node that if
# removed, would minimize M(initial).  If multiple nodes could be removed to
# minimize M(initial), return such a node with the smallest index.
# 
# 
# 
# 
# 
# 
# 
# Example 1:
# 
# 
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# 
# 
# 
# Example 2:
# 
# 
# Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
# Output: 1
# 
# 
# 
# Example 3:
# 
# 
# Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
# Output: 1
# 
# 
# 
# 
# Note:
# 
# 
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] = 1
# 1 <= initial.length < graph.length
# 0 <= initial[i] < graph.length
# 
# 
# 
# 
#

# @lc code=start
from collections import Counter

class DSU:
    def __init__(self, N):
        self.par = list(range(N))
        self.rnk = [0] * N
        self.siz = [1] * N

    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def union(self, x, y):
        xr, yr = map(self.find, (x, y))
        if xr == yr: return
        if self.rnk[xr] < self.rnk[yr]:
            xr, yr = yr, xr
        if self.rnk[xr] == self.rnk[yr]:
            self.rnk[xr] += 1

        self.par[yr] = xr
        self.siz[xr] += self.siz[yr]

    def size(self, x):
        return self.siz[self.find(x)]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # Depth First Search
        # For each node v not in initial, we want to know which nodes u from initial can reach v in the graph G [with u (and its edges) added to G]. Let's say these nodes u "infect" v.
        # Time  complexity: O(N^2)
        # Space complexity: O(N)
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = Counter()
        for v, neighbors in infected_by.items():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.items():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u

        return best[1]


        # Union Find
        # Time  complexity: O(N^2)
        # Space complexity: O(N)
        # N = len(graph)
        # initial_set = set(initial)
        # clean = [x for x in range(N) if x not in initial_set]

        # # clean[u] == 1 if its a node in the graph not in initial.
        # dsu = DSU(N)
        # for u in clean:
        #     for v in clean:
        #         if graph[u][v]:
        #             dsu.union(u, v)

        # # dsu now represents the components of the graph without
        # # any nodes from initial.  Let's call this graph G.
        # count = Counter()
        # node_to_compo = {}
        # for u in initial:
        #     components = set()
        #     for v in clean:
        #         if graph[u][v]:
        #             components.add(dsu.find(v))
        #     node_to_compo[u] = components

        #     for c in components:
        #         count[c] += 1

        # # For each node u in initial, nodeToCompo.get(u)
        # # now has every component from G that u neighbors.
        # best = (-1, None)
        # for u, components in node_to_compo.items():
        #     score = 0
        #     for c in components:
        #         if count[c] == 1: # uniquely infected
        #             score += dsu.size(c)
        #     if score > best[0] or score == best[0] and u < best[1]:
        #         best = (score, u)

        # return best[1]



        
# @lc code=end

